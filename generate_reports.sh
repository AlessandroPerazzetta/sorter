#!/bin/bash

# Generate reports from existing JSON benchmark results
#
# This script reads JSON files generated by run_tests.sh and creates
# HTML and/or text reports without rerunning the benchmarks.

#set -e  # Exit on any error

# Parse command line arguments
GENERATE_HTML=false
GENERATE_TEXT=false
INPUT_JSON=""
SHOW_HELP=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            SHOW_HELP=true
            shift
            ;;
        --html)
            GENERATE_HTML=true
            shift
            ;;
        --text)
            GENERATE_TEXT=true
            shift
            ;;
        --input-json)
            INPUT_JSON="$2"
            shift
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Show help if requested
if [ "$SHOW_HELP" = true ]; then
    cat << 'EOF'
Rust Sorter Report Generator

USAGE:
    ./generate_reports.sh [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    --input-json FILE       JSON results file to process (required)
    --html                  Generate HTML report with interactive charts
    --text                  Generate text report

DESCRIPTION:
    This script generates HTML and/or text reports from existing JSON benchmark
    results created by run_tests.sh. This allows you to regenerate reports with
    different formats or styles without rerunning expensive benchmarks.

EXAMPLES:
    ./generate_reports.sh --input-json reports/benchmark_results_20260216_174512.json --html
    ./generate_reports.sh --input-json reports/benchmark_results_20260216_174512.json --text --html

NOTES:
    - Requires a valid JSON file generated by run_tests.sh
    - Reports are saved to the same directory as the input JSON file
    - HTML reports include interactive charts for performance analysis
EOF
    exit 0
fi

# Validate input
if [ -z "$INPUT_JSON" ]; then
    echo -e "${RED}Error: --input-json is required${NC}"
    echo "Use -h or --help for usage information"
    exit 1
fi

if [ ! -f "$INPUT_JSON" ]; then
    echo -e "${RED}Error: JSON file '$INPUT_JSON' not found${NC}"
    exit 1
fi

if [ "$GENERATE_HTML" = false ] && [ "$GENERATE_TEXT" = false ]; then
    echo -e "${RED}Error: Must specify at least --html or --text${NC}"
    echo "Use -h or --help for usage information"
    exit 1
fi

# Extract timestamp from input file
TIMESTAMP=$(basename "$INPUT_JSON" .json | sed 's/benchmark_results_//')
REPORTS_DIR=$(dirname "$INPUT_JSON")
OUTPUT_FILE="${REPORTS_DIR}/benchmark_results_${TIMESTAMP}.txt"
HTML_FILE="${REPORTS_DIR}/benchmark_results_${TIMESTAMP}.html"

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}    Rust Sorter Report Generator${NC}"
echo -e "${BLUE}========================================${NC}"
echo "Input JSON: $INPUT_JSON"
if [ "$GENERATE_TEXT" = true ]; then
    echo "Text report will be saved to: $OUTPUT_FILE"
fi
if [ "$GENERATE_HTML" = true ]; then
    echo "HTML report will be saved to: $HTML_FILE"
fi
echo ""

# Function to get algorithm display name
get_algo_display_name() {
    local algo=$1
    case $algo in
        "bubble") echo "Bubble Sort" ;;
        "selection") echo "Selection Sort" ;;
        "insertion") echo "Insertion Sort" ;;
        "merge") echo "Merge Sort" ;;
        "quick") echo "Quick Sort" ;;
        "heap") echo "Heap Sort" ;;
        "parallel-bubble") echo "Parallel Bubble Sort" ;;
        "parallel-selection") echo "Parallel Selection Sort" ;;
        "parallel-merge") echo "Parallel Merge Sort" ;;
        "parallel-quick") echo "Parallel Quick Sort" ;;
        "parallel-heap") echo "Parallel Heap Sort" ;;
        "gpu-sort") echo "GPU Sort" ;;
        "gpu-bitonic") echo "GPU Bitonic Sort" ;;
        *) echo "$algo" ;;
    esac
}

# Function to get algorithm category
get_algo_category() {
    local algo=$1
    case $algo in
        "bubble"|"selection"|"insertion"|"merge"|"quick"|"heap") echo "sequential" ;;
        "parallel-"*) echo "parallel" ;;
        "gpu-"*) echo "gpu" ;;
        *) echo "unknown" ;;
    esac
}

# Function to get algorithm color
get_algo_color() {
    local algo=$1
    case $algo in
        "bubble") echo "rgba(231, 76, 60, 0.8)" ;;
        "selection") echo "rgba(243, 156, 18, 0.8)" ;;
        "insertion") echo "rgba(241, 196, 15, 0.8)" ;;
        "merge") echo "rgba(39, 174, 96, 0.8)" ;;
        "quick") echo "rgba(52, 152, 219, 0.8)" ;;
        "heap") echo "rgba(155, 89, 182, 0.8)" ;;
        "parallel-bubble") echo "rgba(192, 57, 43, 0.8)" ;;
        "parallel-selection") echo "rgba(230, 126, 34, 0.8)" ;;
        "parallel-merge") echo "rgba(34, 153, 84, 0.8)" ;;
        "parallel-quick") echo "rgba(41, 128, 185, 0.8)" ;;
        "parallel-heap") echo "rgba(142, 68, 173, 0.8)" ;;
        "gpu-sort") echo "rgba(22, 160, 133, 0.8)" ;;
        "gpu-bitonic") echo "rgba(44, 62, 80, 0.8)" ;;
        *) echo "rgba(149, 165, 166, 0.8)" ;;
    esac
}

# Parse JSON and extract data
# Use jq if available, otherwise fall back to sed/awk parsing
if command -v jq &> /dev/null; then
    # Use jq for proper JSON parsing
    METADATA=$(jq -r '.metadata' "$INPUT_JSON")
    TOTAL_TESTS=$(jq -r '.metadata.total_tests' "$INPUT_JSON")
    SUCCESSFUL_TESTS=$(jq -r '.metadata.successful_tests' "$INPUT_JSON")
    FAILED_TESTS=$(jq -r '.metadata.failed_tests' "$INPUT_JSON")

    # Extract results array
    RESULTS_JSON=$(jq -c '.results[]' "$INPUT_JSON")
else
    echo -e "${YELLOW}Warning: jq not found, using fallback JSON parsing${NC}"

    # Fallback parsing with sed/awk (limited functionality)
    TOTAL_TESTS=$(grep '"total_tests"' "$INPUT_JSON" | sed 's/.*: \([0-9]*\).*/\1/')
    SUCCESSFUL_TESTS=$(grep '"successful_tests"' "$INPUT_JSON" | sed 's/.*: \([0-9]*\).*/\1/')
    FAILED_TESTS=$(grep '"failed_tests"' "$INPUT_JSON" | sed 's/.*: \([0-9]*\).*/\1/')

    # Extract results (this is crude and may not work for complex JSON)
    RESULTS_JSON=$(sed -n '/"results": \[/,/]/p' "$INPUT_JSON" | grep '{' | sed 's/,$//' | sed 's/^[[:space:]]*//')
fi

# Convert results to associative array format for compatibility
declare -A JSON_RESULTS
declare -i idx=0

# Process each result
while IFS= read -r result; do
    if [ -n "$result" ]; then
        # Extract fields using sed
        algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
        data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
        size=$(echo "$result" | sed 's/.*"size":\([0-9]*\).*/\1/')
        time_val=$(echo "$result" | sed 's/.*"time_seconds":\([^,}]*\).*/\1/')
        passes=$(echo "$result" | sed 's/.*"passes":\([^,}]*\).*/\1/')
        success=$(echo "$result" | sed 's/.*"success":\([^}]*\).*/\1/')

        key="$algo-$data_type-$size"
        JSON_RESULTS["$key"]="$result"
        ((idx++))
    fi
done <<< "$RESULTS_JSON"

echo "Parsed $idx test results from JSON"

# Generate text report if requested
if [ "$GENERATE_TEXT" = true ]; then
    echo "Generating text report..."
    {
        echo "Rust Sorter Benchmark Results"
        echo "Generated on: $(date)"
        echo "Source JSON: $INPUT_JSON"
        echo "=========================================="
        echo ""
        echo "Summary:"
        echo "Total tests: $TOTAL_TESTS"
        echo "Successful: $SUCCESSFUL_TESTS"
        echo "Failed: $FAILED_TESTS"
        echo ""
        echo "Detailed Results:"
        echo "----------------------------------------"

        for key in "${!JSON_RESULTS[@]}"; do
            result="${JSON_RESULTS[$key]}"
            algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
            data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
            size=$(echo "$result" | sed 's/.*"size":\([0-9]*\).*/\1/')
            time_val=$(echo "$result" | sed 's/.*"time_seconds":\([^,}]*\).*/\1/')
            passes=$(echo "$result" | sed 's/.*"passes":\([^,}]*\).*/\1/')
            success=$(echo "$result" | sed 's/.*"success":\([^}]*\).*/\1/')

            echo "Algorithm: $algo"
            echo "Data Type: $data_type"
            echo "Size: $size"
            if [ "$success" = "true" ]; then
                echo "Time: ${time_val}s"
                if [ "$passes" != "null" ]; then
                    echo "Passes: $passes"
                fi
            else
                echo "Status: FAILED"
            fi
            echo "----------------------------------------"
        done
    } > "$OUTPUT_FILE"
    echo -e "${GREEN}Text report saved to: $OUTPUT_FILE${NC}"
fi

# Generate HTML report if requested
if [ "$GENERATE_HTML" = true ]; then
    echo "Generating HTML report..."

    # Calculate aggregates for charts
    declare -A algo_times
    declare -A algo_counts
    declare -A data_type_times
    declare -A data_type_counts

    for key in "${!JSON_RESULTS[@]}"; do
        result="${JSON_RESULTS[$key]}"
        algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
        data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
        time_val=$(echo "$result" | sed 's/.*"time_seconds":\([^,}]*\).*/\1/')
        success=$(echo "$result" | sed 's/.*"success":\([^}]*\).*/\1/')

        if [ "$success" = "true" ] && [ "$time_val" != "null" ]; then
            algo_times[$algo]=$(awk -v current="${algo_times[$algo]}" -v add="$time_val" "BEGIN {print current + add}" 2>/dev/null || echo "0")
            algo_counts[$algo]=$((algo_counts[$algo] + 1))
            data_type_times[$data_type]=$(awk -v current="${data_type_times[$data_type]}" -v add="$time_val" "BEGIN {print current + add}" 2>/dev/null || echo "0")
            data_type_counts[$data_type]=$((data_type_counts[$data_type] + 1))
        fi
    done

    # Generate chart data
    ALGO_LABELS=""
    ALGO_AVG_TIMES=""
    ALGO_COLORS=""

    # Get all algorithms that were tested
    declare -A tested_algos
    for key in "${!JSON_RESULTS[@]}"; do
        result="${JSON_RESULTS[$key]}"
        algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
        tested_algos[$algo]=1
    done

    for algo in "${!tested_algos[@]}"; do
        if [ "${algo_counts[$algo]}" -gt 0 ]; then
            avg_time=$(awk "BEGIN {printf \"%.6f\", ${algo_times[$algo]} / ${algo_counts[$algo]}}")
            display_name=$(get_algo_display_name "$algo")
            color=$(get_algo_color "$algo")
            ALGO_LABELS="${ALGO_LABELS}\"${display_name}\", "
            ALGO_AVG_TIMES="${ALGO_AVG_TIMES}${avg_time}, "
            ALGO_COLORS="${ALGO_COLORS}\"${color}\", "
        fi
    done
    ALGO_LABELS="${ALGO_LABELS%, }"
    ALGO_AVG_TIMES="${ALGO_AVG_TIMES%, }"
    ALGO_COLORS="${ALGO_COLORS%, }"

    DATA_TYPE_LABELS=""
    DATA_TYPE_AVG_TIMES=""

    # Get all data types that were tested
    declare -A tested_data_types
    for key in "${!JSON_RESULTS[@]}"; do
        result="${JSON_RESULTS[$key]}"
        data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
        tested_data_types[$data_type]=1
    done

    for data_type in "${!tested_data_types[@]}"; do
        if [ "${data_type_counts[$data_type]}" -gt 0 ]; then
            avg_time=$(awk "BEGIN {printf \"%.6f\", ${data_type_times[$data_type]} / ${data_type_counts[$data_type]}}")
            DATA_TYPE_LABELS="${DATA_TYPE_LABELS}\"${data_type}\", "
            DATA_TYPE_AVG_TIMES="${DATA_TYPE_AVG_TIMES}${avg_time}, "
        fi
    done
    DATA_TYPE_LABELS="${DATA_TYPE_LABELS%, }"
    DATA_TYPE_AVG_TIMES="${DATA_TYPE_AVG_TIMES%, }"

    # Generate HTML content (same as in run_tests.sh)
    cat > "$HTML_FILE" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Sorter Benchmark Results</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .summary {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        .summary h2 {
            margin-top: 0;
            color: #34495e;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        .stat {
            text-align: center;
            margin: 10px;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #27ae60;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .charts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container h3 {
            margin-top: 0;
            color: #34495e;
            text-align: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        tr:hover {
            background-color: #e8f4fd;
        }
        .success { color: #27ae60; font-weight: bold; }
        .failure { color: #e74c3c; font-weight: bold; }
        .time { font-family: 'Courier New', monospace; }
        .footer {
            text-align: center;
            color: #7f8c8d;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
        }
        .algorithm-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .badge {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        .badge:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .badge.selected {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #fff;
        }
        .badge.unselected {
            opacity: 0.4;
        }
        .badge-bubble { background: #e74c3c; color: white; }
        .badge-selection { background: #f39c12; color: white; }
        .badge-insertion { background: #f1c40f; color: black; }
        .badge-merge { background: #27ae60; color: white; }
        .badge-quick { background: #3498db; color: white; }
        .badge-heap { background: #9b59b6; color: white; }
        .badge-parallel-bubble { background: #c0392b; color: white; }
        .badge-parallel-selection { background: #e67e22; color: white; }
        .badge-parallel-merge { background: #229954; color: white; }
        .badge-parallel-quick { background: #2980b9; color: white; }
        .badge-parallel-heap { background: #8e44ad; color: white; }
        .badge-gpu-sort { background: #16a085; color: white; }
        .badge-gpu-bitonic { background: #2c3e50; color: white; }
        .filter-controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }
        .filter-controls h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 0.9em;
        }
        .filter-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .filter-btn {
            padding: 5px 12px;
            border: none;
            border-radius: 4px;
            background: #6c757d;
            color: white;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }
        .filter-btn:hover {
            background: #5a6268;
        }
        .filter-btn.select-all {
            background: #28a745;
        }
        .filter-btn.select-all:hover {
            background: #218838;
        }
        .filter-btn.clear-all {
            background: #dc3545;
        }
        .filter-btn.clear-all:hover {
            background: #c82333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü¶Ä Rust Sorter Benchmark Results</h1>
        <div class="summary">
            <h2>üìä Test Summary</h2>
            <div class="stats" id="summary-stats">
                <!-- Stats will be inserted here -->
            </div>
        </div>

        <h2>üìà Performance Charts</h2>
        <div class="charts">
            <div class="chart-container">
                <h3>Average Time by Algorithm</h3>
                <canvas id="algorithmChart" width="400" height="300"></canvas>
            </div>
            <div class="chart-container">
                <h3>Average Time by Data Type</h3>
                <canvas id="dataTypeChart" width="400" height="300"></canvas>
            </div>
        </div>

        <h2>üè∑Ô∏è Algorithms Tested</h2>
        <div class="algorithm-badges">
            <!-- Algorithm badges will be inserted here -->
        </div>

        <h2>üìã Detailed Results</h2>
        <div class="filter-controls">
            <h4>Filter Results by Algorithm:</h4>
            <div class="filter-buttons">
                <button class="filter-btn select-all" onclick="selectAllAlgorithms()">Select All</button>
                <button class="filter-btn clear-all" onclick="clearAllAlgorithms()">Clear All</button>
            </div>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Algorithm</th>
                    <th>Data Type</th>
                    <th>Size</th>
                    <th>Time (s)</th>
                    <th>Passes</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody id="results-body">
                <!-- Results will be inserted here -->
            </tbody>
        </table>

        <div class="footer">
            <p>Generated on: $(date) | Total Tests: <span id="total-tests"></span></p>
        </div>
    </div>

    <script>
        // Chart data will be inserted here
        <!-- CHART_DATA -->

        // Algorithm filtering functionality
        let selectedAlgorithms = new Set();

        function initializeAlgorithmFilter() {
            // Get all algorithm badges
            const badges = document.querySelectorAll('.badge[data-algorithm]');
            const tableRows = document.querySelectorAll('#results-body tr');

            // Initially select all algorithms
            badges.forEach(badge => {
                const algorithm = badge.getAttribute('data-algorithm');
                selectedAlgorithms.add(algorithm);
                badge.classList.add('selected');
            });

            // Add click event listeners to badges
            badges.forEach(badge => {
                badge.addEventListener('click', function() {
                    const algorithm = this.getAttribute('data-algorithm');
                    toggleAlgorithm(algorithm);
                });
            });

            // Initial filter application
            applyFilter();
        }

        function toggleAlgorithm(algorithm) {
            const badge = document.querySelector(`.badge[data-algorithm="${algorithm}"]`);

            if (selectedAlgorithms.has(algorithm)) {
                selectedAlgorithms.delete(algorithm);
                badge.classList.remove('selected');
                badge.classList.add('unselected');
            } else {
                selectedAlgorithms.add(algorithm);
                badge.classList.add('selected');
                badge.classList.remove('unselected');
            }

            applyFilter();
        }

        function selectAllAlgorithms() {
            const badges = document.querySelectorAll('.badge[data-algorithm]');
            badges.forEach(badge => {
                const algorithm = badge.getAttribute('data-algorithm');
                selectedAlgorithms.add(algorithm);
                badge.classList.add('selected');
                badge.classList.remove('unselected');
            });
            applyFilter();
        }

        function clearAllAlgorithms() {
            const badges = document.querySelectorAll('.badge[data-algorithm]');
            badges.forEach(badge => {
                const algorithm = badge.getAttribute('data-algorithm');
                selectedAlgorithms.delete(algorithm);
                badge.classList.remove('selected');
                badge.classList.add('unselected');
            });
            applyFilter();
        }

        function applyFilter() {
            const tableRows = document.querySelectorAll('#results-body tr');
            let visibleCount = 0;

            tableRows.forEach(row => {
                const algorithm = row.getAttribute('data-algorithm');
                if (selectedAlgorithms.has(algorithm)) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Update summary stats to show filtered results
            updateFilteredStats(visibleCount);
        }

        function updateFilteredStats(visibleCount) {
            const totalRows = document.querySelectorAll('#results-body tr').length;
            const summaryContainer = document.getElementById('summary-stats');

            // Calculate filtered successful/failed counts
            let filteredSuccessful = 0;
            let filteredFailed = 0;

            document.querySelectorAll('#results-body tr').forEach(row => {
                if (row.style.display !== 'none') {
                    const statusCell = row.querySelector('td:last-child');
                    if (statusCell && statusCell.textContent.includes('Success')) {
                        filteredSuccessful++;
                    } else if (statusCell && statusCell.textContent.includes('Failed')) {
                        filteredFailed++;
                    }
                }
            });

            const filteredStats = `
                <div class="stat">
                    <div class="stat-number">${visibleCount}</div>
                    <div class="stat-label">Filtered Tests</div>
                </div>
                <div class="stat">
                    <div class="stat-number" style="color: #27ae60;">${filteredSuccessful}</div>
                    <div class="stat-label">Successful</div>
                </div>
                <div class="stat">
                    <div class="stat-number" style="color: #e74c3c;">${filteredFailed}</div>
                    <div class="stat-label">Failed</div>
                </div>
            `;

            summaryContainer.innerHTML = filteredStats;
        }

        // Initialize filtering when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeAlgorithmFilter();
        });
    </script>
</body>
</html>
EOF

    # Generate results table and badges
    RESULTS_DATA=""
    for key in "${!JSON_RESULTS[@]}"; do
        result="${JSON_RESULTS[$key]}"
        algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
        data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
        size=$(echo "$result" | sed 's/.*"size":\([0-9]*\).*/\1/')
        time_val=$(echo "$result" | sed 's/.*"time_seconds":\([^,}]*\).*/\1/')
        passes=$(echo "$result" | sed 's/.*"passes":\([^,}]*\).*/\1/')
        success=$(echo "$result" | sed 's/.*"success":\([^}]*\).*/\1/')

        badge_class="badge-${algo}"
        display_name=$(get_algo_display_name "$algo")

        if [ "$success" = "true" ]; then
            status_class="success"
            status_text="‚úì Success"
            display_time="${time_val}"
            display_passes="$passes"
        else
            status_class="failure"
            status_text="‚úó Failed"
            display_time="N/A"
            display_passes="N/A"
        fi

        RESULTS_DATA="${RESULTS_DATA}<tr data-algorithm=\"${algo}\"><td><span class=\"badge ${badge_class}\">${display_name}</span></td><td>${data_type}</td><td>${size}</td><td class=\"time\">${display_time}</td><td>${display_passes}</td><td class=\"${status_class}\">${status_text}</td></tr>"
    done

    # Generate dynamic algorithm badges
    declare -A tested_algorithms
    for key in "${!JSON_RESULTS[@]}"; do
        result="${JSON_RESULTS[$key]}"
        algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
        tested_algorithms[$algo]=1
    done

    BADGES_HTML=""
    SEQUENTIAL_BADGES=""
    PARALLEL_BADGES=""
    GPU_BADGES=""

    for algo in "${!tested_algorithms[@]}"; do
        display_name=$(get_algo_display_name "$algo")
        badge_class="badge-${algo}"

        case $algo in
            "bubble"|"selection"|"insertion"|"merge"|"quick"|"heap")
                SEQUENTIAL_BADGES="${SEQUENTIAL_BADGES}<span class=\"badge ${badge_class}\" data-algorithm=\"${algo}\">${display_name}</span> "
                ;;
            "parallel-"*)
                PARALLEL_BADGES="${PARALLEL_BADGES}<span class=\"badge ${badge_class}\" data-algorithm=\"${algo}\">${display_name}</span> "
                ;;
            "gpu-"*)
                GPU_BADGES="${GPU_BADGES}<span class=\"badge ${badge_class}\" data-algorithm=\"${algo}\">${display_name}</span> "
                ;;
        esac
    done

    if [ -n "$SEQUENTIAL_BADGES" ]; then
        BADGES_HTML="${BADGES_HTML}<h3>Sequential Algorithms</h3>${SEQUENTIAL_BADGES}"
    fi
    if [ -n "$PARALLEL_BADGES" ]; then
        BADGES_HTML="${BADGES_HTML}<h3>Parallel CPU Algorithms</h3>${PARALLEL_BADGES}"
    fi
    if [ -n "$GPU_BADGES" ]; then
        BADGES_HTML="${BADGES_HTML}<h3>GPU-Accelerated Algorithms</h3>${GPU_BADGES}"
    fi

    # Generate chart script
    CHART_SCRIPT="
        // Algorithm performance chart
        const algoCtx = document.getElementById('algorithmChart').getContext('2d');
        new Chart(algoCtx, {
            type: 'bar',
            data: {
                labels: [${ALGO_LABELS}],
                datasets: [{
                    label: 'Average Time (seconds)',
                    data: [${ALGO_AVG_TIMES}],
                    backgroundColor: [${ALGO_COLORS}],
                    borderColor: [${ALGO_COLORS}],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Algorithm'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Average Execution Time by Sorting Algorithm'
                    }
                }
            }
        });

        // Data type performance chart
        const dataCtx = document.getElementById('dataTypeChart').getContext('2d');
        new Chart(dataCtx, {
            type: 'line',
            data: {
                labels: [${DATA_TYPE_LABELS}],
                datasets: [{
                    label: 'Average Time (seconds)',
                    data: [${DATA_TYPE_AVG_TIMES}],
                    backgroundColor: 'rgba(52, 152, 219, 0.2)',
                    borderColor: 'rgba(52, 152, 219, 1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Data Type'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Average Execution Time by Data Type'
                    }
                }
            }
        });
"

    # Insert data into HTML
    sed -i "s|<!-- Stats will be inserted here -->|<div class=\"stat\"><div class=\"stat-number\">$TOTAL_TESTS</div><div class=\"stat-label\">Total Tests</div></div><div class=\"stat\"><div class=\"stat-number\" style=\"color: #27ae60;\">$SUCCESSFUL_TESTS</div><div class=\"stat-label\">Successful</div></div><div class=\"stat\"><div class=\"stat-number\" style=\"color: #e74c3c;\">$FAILED_TESTS</div><div class=\"stat-label\">Failed</div></div>|" "$HTML_FILE"
    sed -i "s|<!-- Algorithm badges will be inserted here -->|${BADGES_HTML}|" "$HTML_FILE"

    echo "$RESULTS_DATA" > /tmp/results_data.html
    sed -i '/<!-- Results will be inserted here -->/r /tmp/results_data.html' "$HTML_FILE"
    sed -i '/<!-- Results will be inserted here -->/d' "$HTML_FILE"

    echo "$CHART_SCRIPT" > /tmp/chart_data.js
    sed -i '/<!-- CHART_DATA -->/r /tmp/chart_data.js' "$HTML_FILE"
    sed -i '/<!-- CHART_DATA -->/d' "$HTML_FILE"

    sed -i "s|<span id=\"total-tests\"></span>|$TOTAL_TESTS|" "$HTML_FILE"

    echo -e "${GREEN}HTML report saved to: $HTML_FILE${NC}"
fi

echo -e "${GREEN}Report generation complete!${NC}"