#!/bin/bash

# Generate reports from existing JSON benchmark results
#
# This script reads JSON files generated by run_tests.sh and creates
# HTML and/or text reports without rerunning the benchmarks.

#set -e  # Exit on any error

# Parse command line arguments
GENERATE_HTML=false
GENERATE_TEXT=false
INPUT_JSON=""
SHOW_HELP=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            SHOW_HELP=true
            shift
            ;;
        --html)
            GENERATE_HTML=true
            shift
            ;;
        --text)
            GENERATE_TEXT=true
            shift
            ;;
        --input-json)
            INPUT_JSON="$2"
            shift
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
    esac
done

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Show help if requested
if [ "$SHOW_HELP" = true ]; then
    cat << 'EOF'
Rust Sorter Report Generator

USAGE:
    ./generate_reports.sh [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    --input-json FILE       JSON results file to process (required)
    --html                  Generate HTML report with interactive charts
    --text                  Generate text report

DESCRIPTION:
    This script generates HTML and/or text reports from existing JSON benchmark
    results created by run_tests.sh. This allows you to regenerate reports with
    different formats or styles without rerunning expensive benchmarks.

EXAMPLES:
    ./generate_reports.sh --input-json reports/benchmark_results_20260216_174512.json --html
    ./generate_reports.sh --input-json reports/benchmark_results_20260216_174512.json --text --html

NOTES:
    - Requires a valid JSON file generated by run_tests.sh
    - Reports are saved to the same directory as the input JSON file
    - HTML reports include interactive charts for performance analysis
EOF
    exit 0
fi

# Validate input
if [ -z "$INPUT_JSON" ]; then
    echo -e "${RED}Error: --input-json is required${NC}"
    echo "Use -h or --help for usage information"
    exit 1
fi

if [ ! -f "$INPUT_JSON" ]; then
    echo -e "${RED}Error: JSON file '$INPUT_JSON' not found${NC}"
    exit 1
fi

if [ "$GENERATE_HTML" = false ] && [ "$GENERATE_TEXT" = false ]; then
    echo -e "${RED}Error: Must specify at least --html or --text${NC}"
    echo "Use -h or --help for usage information"
    exit 1
fi

# Extract timestamp from input file
TIMESTAMP=$(basename "$INPUT_JSON" .json | sed 's/benchmark_results_//')
REPORTS_DIR=$(dirname "$INPUT_JSON")
OUTPUT_FILE="${REPORTS_DIR}/benchmark_results_${TIMESTAMP}.txt"
HTML_FILE="${REPORTS_DIR}/benchmark_results_${TIMESTAMP}.html"

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}    Rust Sorter Report Generator${NC}"
echo -e "${BLUE}========================================${NC}"
echo "Input JSON: $INPUT_JSON"
if [ "$GENERATE_TEXT" = true ]; then
    echo "Text report will be saved to: $OUTPUT_FILE"
fi
if [ "$GENERATE_HTML" = true ]; then
    echo "HTML report will be saved to: $HTML_FILE"
fi
echo ""

# Function to get algorithm display name
get_algo_display_name() {
    local algo=$1
    case $algo in
        "bubble") echo "Bubble Sort" ;;
        "selection") echo "Selection Sort" ;;
        "insertion") echo "Insertion Sort" ;;
        "merge") echo "Merge Sort" ;;
        "quick") echo "Quick Sort" ;;
        "heap") echo "Heap Sort" ;;
        "parallel-bubble") echo "Parallel Bubble Sort" ;;
        "parallel-selection") echo "Parallel Selection Sort" ;;
        "parallel-merge") echo "Parallel Merge Sort" ;;
        "parallel-quick") echo "Parallel Quick Sort" ;;
        "parallel-heap") echo "Parallel Heap Sort" ;;
        "gpu-sort") echo "GPU Sort" ;;
        "gpu-bitonic") echo "GPU Bitonic Sort" ;;
        *) echo "$algo" ;;
    esac
}

# Function to get algorithm category
get_algo_category() {
    local algo=$1
    case $algo in
        "bubble"|"selection"|"insertion"|"merge"|"quick"|"heap") echo "sequential" ;;
        "parallel-"*) echo "parallel" ;;
        "gpu-"*) echo "gpu" ;;
        *) echo "unknown" ;;
    esac
}

# Function to get algorithm color
get_algo_color() {
    local algo=$1
    case $algo in
        "bubble") echo "rgba(231, 76, 60, 0.8)" ;;
        "selection") echo "rgba(243, 156, 18, 0.8)" ;;
        "insertion") echo "rgba(241, 196, 15, 0.8)" ;;
        "merge") echo "rgba(39, 174, 96, 0.8)" ;;
        "quick") echo "rgba(52, 152, 219, 0.8)" ;;
        "heap") echo "rgba(155, 89, 182, 0.8)" ;;
        "parallel-bubble") echo "rgba(192, 57, 43, 0.8)" ;;
        "parallel-selection") echo "rgba(230, 126, 34, 0.8)" ;;
        "parallel-merge") echo "rgba(34, 153, 84, 0.8)" ;;
        "parallel-quick") echo "rgba(41, 128, 185, 0.8)" ;;
        "parallel-heap") echo "rgba(142, 68, 173, 0.8)" ;;
        "gpu-sort") echo "rgba(22, 160, 133, 0.8)" ;;
        "gpu-bitonic") echo "rgba(44, 62, 80, 0.8)" ;;
        *) echo "rgba(149, 165, 166, 0.8)" ;;
    esac
}

# Parse JSON and extract data
# Use jq if available, otherwise fall back to sed/awk parsing
if command -v jq &> /dev/null; then
    # Use jq for proper JSON parsing
    METADATA=$(jq -r '.metadata' "$INPUT_JSON")
    TOTAL_TESTS=$(jq -r '.metadata.total_tests' "$INPUT_JSON")
    SUCCESSFUL_TESTS=$(jq -r '.metadata.successful_tests' "$INPUT_JSON")
    FAILED_TESTS=$(jq -r '.metadata.failed_tests' "$INPUT_JSON")

    # Extract results array
    RESULTS_JSON=$(jq -c '.results[]' "$INPUT_JSON")
else
    echo -e "${YELLOW}Warning: jq not found, using fallback JSON parsing${NC}"

    # Fallback parsing with sed/awk (limited functionality)
    TOTAL_TESTS=$(grep '"total_tests"' "$INPUT_JSON" | sed 's/.*: \([0-9]*\).*/\1/')
    SUCCESSFUL_TESTS=$(grep '"successful_tests"' "$INPUT_JSON" | sed 's/.*: \([0-9]*\).*/\1/')
    FAILED_TESTS=$(grep '"failed_tests"' "$INPUT_JSON" | sed 's/.*: \([0-9]*\).*/\1/')

    # Extract results (this is crude and may not work for complex JSON)
    RESULTS_JSON=$(sed -n '/"results": \[/,/]/p' "$INPUT_JSON" | grep '{' | sed 's/,$//' | sed 's/^[[:space:]]*//')
fi

# Convert results to associative array format for compatibility
declare -A JSON_RESULTS
declare -i idx=0

# Process each result
while IFS= read -r result; do
    if [ -n "$result" ]; then
        # Extract fields using sed
        algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
        data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
        size=$(echo "$result" | sed 's/.*"size":\([0-9]*\).*/\1/')
        time_val=$(echo "$result" | sed 's/.*"time_seconds":\([^,}]*\).*/\1/')
        passes=$(echo "$result" | sed 's/.*"passes":\([^,}]*\).*/\1/')
        success=$(echo "$result" | sed 's/.*"success":\([^}]*\).*/\1/')

        key="$algo-$data_type-$size"
        JSON_RESULTS["$key"]="$result"
        ((idx++))
    fi
done <<< "$RESULTS_JSON"

echo "Parsed $idx test results from JSON"

# Generate text report if requested
if [ "$GENERATE_TEXT" = true ]; then
    echo "Generating text report..."
    {
        echo "Rust Sorter Benchmark Results"
        echo "Generated on: $(date)"
        echo "Source JSON: $INPUT_JSON"
        echo "=========================================="
        echo ""
        echo "Summary:"
        echo "Total tests: $TOTAL_TESTS"
        echo "Successful: $SUCCESSFUL_TESTS"
        echo "Failed: $FAILED_TESTS"
        echo ""
        echo "Detailed Results:"
        echo "----------------------------------------"

        for key in "${!JSON_RESULTS[@]}"; do
            result="${JSON_RESULTS[$key]}"
            algo=$(echo "$result" | sed 's/.*"algorithm":"\([^"]*\)".*/\1/')
            data_type=$(echo "$result" | sed 's/.*"data_type":"\([^"]*\)".*/\1/')
            size=$(echo "$result" | sed 's/.*"size":\([0-9]*\).*/\1/')
            time_val=$(echo "$result" | sed 's/.*"time_seconds":\([^,}]*\).*/\1/')
            passes=$(echo "$result" | sed 's/.*"passes":\([^,}]*\).*/\1/')
            success=$(echo "$result" | sed 's/.*"success":\([^}]*\).*/\1/')

            echo "Algorithm: $algo"
            echo "Data Type: $data_type"
            echo "Size: $size"
            if [ "$success" = "true" ]; then
                echo "Time: ${time_val}s"
                if [ "$passes" != "null" ]; then
                    echo "Passes: $passes"
                fi
            else
                echo "Status: FAILED"
            fi
            echo "----------------------------------------"
        done
    } > "$OUTPUT_FILE"
    echo -e "${GREEN}Text report saved to: $OUTPUT_FILE${NC}"
fi

# Generate HTML report if requested
if [ "$GENERATE_HTML" = true ]; then
    cp html/report_template.html "$HTML_FILE"
    # Inject JSON data into the HTML
    sed "/<!-- BENCHMARK_DATA -->/{
r $INPUT_JSON
d
}" "$HTML_FILE" > "${HTML_FILE}.tmp" && mv "${HTML_FILE}.tmp" "$HTML_FILE"
    echo -e "${GREEN}HTML report saved to: $HTML_FILE${NC}"
fi

echo -e "${GREEN}Report generation complete!${NC}"